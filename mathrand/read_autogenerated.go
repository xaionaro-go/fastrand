package mathrand

import (
	"unsafe"
)

// This file was automatically generated by github.com/xaionaro-go/rand/internal/autogen

// ReadUint64AddRotateMultiply is an analog of math/rand.Read. This random
// numbers could easily be predicted (it's not an analog of crypto/rand.Read).
//
// Applied PRNG method:
// Uint64AddRotateMultiply is a fast analog of `math/rand.Uint64`.
//
// The reliability on statistical tests of this method is unknown. This is
// improved LCG method, so see also Uint64MultiplyAdd.
func (prng *PRNG) ReadUint64AddRotateMultiply(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state64Temp0 := prng.state64[0]
		for f := e - 8; p <= f; p += 8 {
			state64Temp0 += primeNumber64bit1
			state64Temp0 = rotateLeft64(state64Temp0, 32)
			state64Temp0 *= primeNumber64bit0
			*(*uint64)((unsafe.Pointer)(p)) = state64Temp0
		}
		prng.state64[0] = state64Temp0
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint64AddRotateMultiply()
	if e-p >= 4 {
		*(*uint32)((unsafe.Pointer)(p)) = uint32(rest)
		rest >>= 32
		p += 4
	}
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) = uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) = uint8(rest)
	}
	return
}

// XORReadUint64AddRotateMultiply XORs argument "b" with a pseudo-random value.
// The result is the same (but faster) as:
//
// 	x := make([]byte, len(b))
// 	mathrand.ReadUint64AddRotateMultiply(x)
// 	for i := range b {
// 		b[i] ^= x[i]
// 	}
func (prng *PRNG) XORReadUint64AddRotateMultiply(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state64Temp0 := prng.state64[0]
		for f := e - 8; p <= f; p += 8 {
			state64Temp0 += primeNumber64bit1
			state64Temp0 = rotateLeft64(state64Temp0, 32)
			state64Temp0 *= primeNumber64bit0
			*(*uint64)((unsafe.Pointer)(p)) ^= state64Temp0
		}
		prng.state64[0] = state64Temp0
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint64AddRotateMultiply()
	if e-p >= 4 {
		*(*uint32)((unsafe.Pointer)(p)) ^= uint32(rest)
		rest >>= 32
		p += 4
	}
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) ^= uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) ^= uint8(rest)
	}
	return
}

// ReadUint64AddRotateMultiplyWithReseed is an analog of math/rand.Read. This random
// numbers could easily be predicted (it's not an analog of crypto/rand.Read).
//
// "Reseed" forces to use a new seed (generated using XORShift method) on setting value to
// a pointer `& 0xff < 8`. Sometimes it allows to improve randomness of random numbers with a
// small performance impact.
// This method makes sense only if len(b) is large enough (>= 256 bytes).
// Otherwise it could affect strongly performance or it will not improve the randomness.
//
// Applied PRNG method:
// Uint64AddRotateMultiply is a fast analog of `math/rand.Uint64`.
//
// The reliability on statistical tests of this method is unknown. This is
// improved LCG method, so see also Uint64MultiplyAdd.
func (prng *PRNG) ReadUint64AddRotateMultiplyWithReseed(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state64Temp0 := prng.state64[0]
		for f := e - 8; p <= f; p += 8 {
			state64Temp0 += primeNumber64bit1
			state64Temp0 = rotateLeft64(state64Temp0, 32)
			state64Temp0 *= primeNumber64bit0
			*(*uint64)((unsafe.Pointer)(p)) = state64Temp0
			if p&0xff < 8 {
				continue
			}
			state64Temp0 = xorShift64(state64Temp0 ^ primeNumber64bit0)
		}
		prng.state64[0] = state64Temp0
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint64AddRotateMultiply()
	if e-p >= 4 {
		*(*uint32)((unsafe.Pointer)(p)) = uint32(rest)
		rest >>= 32
		p += 4
	}
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) = uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) = uint8(rest)
	}
	return
}

// XORReadUint64AddRotateMultiplyWithReseed XORs argument "b" with a pseudo-random value.
// The result is the same (but faster) as:
//
// 	x := make([]byte, len(b))
// 	mathrand.ReadUint64AddRotateMultiplyWithReseed(x)
// 	for i := range b {
// 		b[i] ^= x[i]
// 	}
func (prng *PRNG) XORReadUint64AddRotateMultiplyWithReseed(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state64Temp0 := prng.state64[0]
		for f := e - 8; p <= f; p += 8 {
			state64Temp0 += primeNumber64bit1
			state64Temp0 = rotateLeft64(state64Temp0, 32)
			state64Temp0 *= primeNumber64bit0
			*(*uint64)((unsafe.Pointer)(p)) ^= state64Temp0
			if p&0xff < 8 {
				continue
			}
			state64Temp0 = xorShift64(state64Temp0 ^ primeNumber64bit0)
		}
		prng.state64[0] = state64Temp0
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint64AddRotateMultiply()
	if e-p >= 4 {
		*(*uint32)((unsafe.Pointer)(p)) ^= uint32(rest)
		rest >>= 32
		p += 4
	}
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) ^= uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) ^= uint8(rest)
	}
	return
}

// ReadUint64AddNRotateMultiply is an analog of math/rand.Read. This random
// numbers could easily be predicted (it's not an analog of crypto/rand.Read).
//
// Applied PRNG method:
// Uint64AddNRotateMultiply is a fast analog of `math/rand.Uint64`.
//
// The reliability on statistical tests of this method is unknown. This is
// improved LCG method, so see also Uint64MultiplyAdd.
func (prng *PRNG) ReadUint64AddNRotateMultiply(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state64Temp0 := prng.state64[0]
		for f := e - 8; p <= f; p += 8 {
			state64Temp0 += primeNumber64bit1
			r := 28 + int(state64Temp0&0x7)
			state64Temp0 = rotateLeft64(state64Temp0, r)
			state64Temp0 *= primeNumber64bit0
			*(*uint64)((unsafe.Pointer)(p)) = state64Temp0
		}
		prng.state64[0] = state64Temp0
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint64AddNRotateMultiply()
	if e-p >= 4 {
		*(*uint32)((unsafe.Pointer)(p)) = uint32(rest)
		rest >>= 32
		p += 4
	}
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) = uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) = uint8(rest)
	}
	return
}

// XORReadUint64AddNRotateMultiply XORs argument "b" with a pseudo-random value.
// The result is the same (but faster) as:
//
// 	x := make([]byte, len(b))
// 	mathrand.ReadUint64AddNRotateMultiply(x)
// 	for i := range b {
// 		b[i] ^= x[i]
// 	}
func (prng *PRNG) XORReadUint64AddNRotateMultiply(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state64Temp0 := prng.state64[0]
		for f := e - 8; p <= f; p += 8 {
			state64Temp0 += primeNumber64bit1
			r := 28 + int(state64Temp0&0x7)
			state64Temp0 = rotateLeft64(state64Temp0, r)
			state64Temp0 *= primeNumber64bit0
			*(*uint64)((unsafe.Pointer)(p)) ^= state64Temp0
		}
		prng.state64[0] = state64Temp0
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint64AddNRotateMultiply()
	if e-p >= 4 {
		*(*uint32)((unsafe.Pointer)(p)) ^= uint32(rest)
		rest >>= 32
		p += 4
	}
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) ^= uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) ^= uint8(rest)
	}
	return
}

// ReadUint64AddNRotateMultiplyWithReseed is an analog of math/rand.Read. This random
// numbers could easily be predicted (it's not an analog of crypto/rand.Read).
//
// "Reseed" forces to use a new seed (generated using XORShift method) on setting value to
// a pointer `& 0xff < 8`. Sometimes it allows to improve randomness of random numbers with a
// small performance impact.
// This method makes sense only if len(b) is large enough (>= 256 bytes).
// Otherwise it could affect strongly performance or it will not improve the randomness.
//
// Applied PRNG method:
// Uint64AddNRotateMultiply is a fast analog of `math/rand.Uint64`.
//
// The reliability on statistical tests of this method is unknown. This is
// improved LCG method, so see also Uint64MultiplyAdd.
func (prng *PRNG) ReadUint64AddNRotateMultiplyWithReseed(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state64Temp0 := prng.state64[0]
		for f := e - 8; p <= f; p += 8 {
			state64Temp0 += primeNumber64bit1
			r := 28 + int(state64Temp0&0x7)
			state64Temp0 = rotateLeft64(state64Temp0, r)
			state64Temp0 *= primeNumber64bit0
			*(*uint64)((unsafe.Pointer)(p)) = state64Temp0
			if p&0xff < 8 {
				continue
			}
			state64Temp0 = xorShift64(state64Temp0 ^ primeNumber64bit0)
		}
		prng.state64[0] = state64Temp0
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint64AddNRotateMultiply()
	if e-p >= 4 {
		*(*uint32)((unsafe.Pointer)(p)) = uint32(rest)
		rest >>= 32
		p += 4
	}
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) = uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) = uint8(rest)
	}
	return
}

// XORReadUint64AddNRotateMultiplyWithReseed XORs argument "b" with a pseudo-random value.
// The result is the same (but faster) as:
//
// 	x := make([]byte, len(b))
// 	mathrand.ReadUint64AddNRotateMultiplyWithReseed(x)
// 	for i := range b {
// 		b[i] ^= x[i]
// 	}
func (prng *PRNG) XORReadUint64AddNRotateMultiplyWithReseed(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state64Temp0 := prng.state64[0]
		for f := e - 8; p <= f; p += 8 {
			state64Temp0 += primeNumber64bit1
			r := 28 + int(state64Temp0&0x7)
			state64Temp0 = rotateLeft64(state64Temp0, r)
			state64Temp0 *= primeNumber64bit0
			*(*uint64)((unsafe.Pointer)(p)) ^= state64Temp0
			if p&0xff < 8 {
				continue
			}
			state64Temp0 = xorShift64(state64Temp0 ^ primeNumber64bit0)
		}
		prng.state64[0] = state64Temp0
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint64AddNRotateMultiply()
	if e-p >= 4 {
		*(*uint32)((unsafe.Pointer)(p)) ^= uint32(rest)
		rest >>= 32
		p += 4
	}
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) ^= uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) ^= uint8(rest)
	}
	return
}

// ReadUint64MultiplyAdd is an analog of math/rand.Read. This random
// numbers could easily be predicted (it's not an analog of crypto/rand.Read).
//
// Applied PRNG method:
// Uint64MultiplyAdd is a fast (but week) analog of `math/rand.Uint64`.
//
// See also: https://en.wikipedia.org/wiki/Linear_congruential_generator
func (prng *PRNG) ReadUint64MultiplyAdd(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state64Temp0 := prng.state64[0]
		for f := e - 8; p <= f; p += 8 {
			state64Temp0 *= primeNumber64bit0
			state64Temp0 += primeNumber64bit1
			*(*uint64)((unsafe.Pointer)(p)) = state64Temp0
		}
		prng.state64[0] = state64Temp0
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint64MultiplyAdd()
	if e-p >= 4 {
		*(*uint32)((unsafe.Pointer)(p)) = uint32(rest)
		rest >>= 32
		p += 4
	}
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) = uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) = uint8(rest)
	}
	return
}

// XORReadUint64MultiplyAdd XORs argument "b" with a pseudo-random value.
// The result is the same (but faster) as:
//
// 	x := make([]byte, len(b))
// 	mathrand.ReadUint64MultiplyAdd(x)
// 	for i := range b {
// 		b[i] ^= x[i]
// 	}
func (prng *PRNG) XORReadUint64MultiplyAdd(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state64Temp0 := prng.state64[0]
		for f := e - 8; p <= f; p += 8 {
			state64Temp0 *= primeNumber64bit0
			state64Temp0 += primeNumber64bit1
			*(*uint64)((unsafe.Pointer)(p)) ^= state64Temp0
		}
		prng.state64[0] = state64Temp0
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint64MultiplyAdd()
	if e-p >= 4 {
		*(*uint32)((unsafe.Pointer)(p)) ^= uint32(rest)
		rest >>= 32
		p += 4
	}
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) ^= uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) ^= uint8(rest)
	}
	return
}

// ReadUint64MultiplyAddWithReseed is an analog of math/rand.Read. This random
// numbers could easily be predicted (it's not an analog of crypto/rand.Read).
//
// "Reseed" forces to use a new seed (generated using XORShift method) on setting value to
// a pointer `& 0xff < 8`. Sometimes it allows to improve randomness of random numbers with a
// small performance impact.
// This method makes sense only if len(b) is large enough (>= 256 bytes).
// Otherwise it could affect strongly performance or it will not improve the randomness.
//
// Applied PRNG method:
// Uint64MultiplyAdd is a fast (but week) analog of `math/rand.Uint64`.
//
// See also: https://en.wikipedia.org/wiki/Linear_congruential_generator
func (prng *PRNG) ReadUint64MultiplyAddWithReseed(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state64Temp0 := prng.state64[0]
		for f := e - 8; p <= f; p += 8 {
			state64Temp0 *= primeNumber64bit0
			state64Temp0 += primeNumber64bit1
			*(*uint64)((unsafe.Pointer)(p)) = state64Temp0
			if p&0xff < 8 {
				continue
			}
			state64Temp0 = xorShift64(state64Temp0 ^ primeNumber64bit0)
		}
		prng.state64[0] = state64Temp0
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint64MultiplyAdd()
	if e-p >= 4 {
		*(*uint32)((unsafe.Pointer)(p)) = uint32(rest)
		rest >>= 32
		p += 4
	}
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) = uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) = uint8(rest)
	}
	return
}

// XORReadUint64MultiplyAddWithReseed XORs argument "b" with a pseudo-random value.
// The result is the same (but faster) as:
//
// 	x := make([]byte, len(b))
// 	mathrand.ReadUint64MultiplyAddWithReseed(x)
// 	for i := range b {
// 		b[i] ^= x[i]
// 	}
func (prng *PRNG) XORReadUint64MultiplyAddWithReseed(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state64Temp0 := prng.state64[0]
		for f := e - 8; p <= f; p += 8 {
			state64Temp0 *= primeNumber64bit0
			state64Temp0 += primeNumber64bit1
			*(*uint64)((unsafe.Pointer)(p)) ^= state64Temp0
			if p&0xff < 8 {
				continue
			}
			state64Temp0 = xorShift64(state64Temp0 ^ primeNumber64bit0)
		}
		prng.state64[0] = state64Temp0
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint64MultiplyAdd()
	if e-p >= 4 {
		*(*uint32)((unsafe.Pointer)(p)) ^= uint32(rest)
		rest >>= 32
		p += 4
	}
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) ^= uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) ^= uint8(rest)
	}
	return
}

// ReadUint64AddRotate is an analog of math/rand.Read. This random
// numbers could easily be predicted (it's not an analog of crypto/rand.Read).
//
// Applied PRNG method:
// Uint64AddRotate is a very fast (but weak) analog of `math/rand.Uint64`.
func (prng *PRNG) ReadUint64AddRotate(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state64Temp0 := prng.state64[0]
		for f := e - 8; p <= f; p += 8 {
			state64Temp0 += primeNumber64bit1
			state64Temp0 = rotateLeft64(state64Temp0, 32)
			*(*uint64)((unsafe.Pointer)(p)) = state64Temp0
		}
		prng.state64[0] = state64Temp0
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint64AddRotate()
	if e-p >= 4 {
		*(*uint32)((unsafe.Pointer)(p)) = uint32(rest)
		rest >>= 32
		p += 4
	}
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) = uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) = uint8(rest)
	}
	return
}

// XORReadUint64AddRotate XORs argument "b" with a pseudo-random value.
// The result is the same (but faster) as:
//
// 	x := make([]byte, len(b))
// 	mathrand.ReadUint64AddRotate(x)
// 	for i := range b {
// 		b[i] ^= x[i]
// 	}
func (prng *PRNG) XORReadUint64AddRotate(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state64Temp0 := prng.state64[0]
		for f := e - 8; p <= f; p += 8 {
			state64Temp0 += primeNumber64bit1
			state64Temp0 = rotateLeft64(state64Temp0, 32)
			*(*uint64)((unsafe.Pointer)(p)) ^= state64Temp0
		}
		prng.state64[0] = state64Temp0
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint64AddRotate()
	if e-p >= 4 {
		*(*uint32)((unsafe.Pointer)(p)) ^= uint32(rest)
		rest >>= 32
		p += 4
	}
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) ^= uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) ^= uint8(rest)
	}
	return
}

// ReadUint64AddRotateWithReseed is an analog of math/rand.Read. This random
// numbers could easily be predicted (it's not an analog of crypto/rand.Read).
//
// "Reseed" forces to use a new seed (generated using XORShift method) on setting value to
// a pointer `& 0xff < 8`. Sometimes it allows to improve randomness of random numbers with a
// small performance impact.
// This method makes sense only if len(b) is large enough (>= 256 bytes).
// Otherwise it could affect strongly performance or it will not improve the randomness.
//
// Applied PRNG method:
// Uint64AddRotate is a very fast (but weak) analog of `math/rand.Uint64`.
func (prng *PRNG) ReadUint64AddRotateWithReseed(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state64Temp0 := prng.state64[0]
		for f := e - 8; p <= f; p += 8 {
			state64Temp0 += primeNumber64bit1
			state64Temp0 = rotateLeft64(state64Temp0, 32)
			*(*uint64)((unsafe.Pointer)(p)) = state64Temp0
			if p&0xff < 8 {
				continue
			}
			state64Temp0 = xorShift64(state64Temp0 ^ primeNumber64bit0)
		}
		prng.state64[0] = state64Temp0
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint64AddRotate()
	if e-p >= 4 {
		*(*uint32)((unsafe.Pointer)(p)) = uint32(rest)
		rest >>= 32
		p += 4
	}
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) = uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) = uint8(rest)
	}
	return
}

// XORReadUint64AddRotateWithReseed XORs argument "b" with a pseudo-random value.
// The result is the same (but faster) as:
//
// 	x := make([]byte, len(b))
// 	mathrand.ReadUint64AddRotateWithReseed(x)
// 	for i := range b {
// 		b[i] ^= x[i]
// 	}
func (prng *PRNG) XORReadUint64AddRotateWithReseed(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state64Temp0 := prng.state64[0]
		for f := e - 8; p <= f; p += 8 {
			state64Temp0 += primeNumber64bit1
			state64Temp0 = rotateLeft64(state64Temp0, 32)
			*(*uint64)((unsafe.Pointer)(p)) ^= state64Temp0
			if p&0xff < 8 {
				continue
			}
			state64Temp0 = xorShift64(state64Temp0 ^ primeNumber64bit0)
		}
		prng.state64[0] = state64Temp0
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint64AddRotate()
	if e-p >= 4 {
		*(*uint32)((unsafe.Pointer)(p)) ^= uint32(rest)
		rest >>= 32
		p += 4
	}
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) ^= uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) ^= uint8(rest)
	}
	return
}

// ReadUint64AddIfShiftXOR is an analog of math/rand.Read. This random
// numbers could easily be predicted (it's not an analog of crypto/rand.Read).
//
// Applied PRNG method:
// Uint64AddIfShiftXOR is a very fast (but weak) analog of `math/rand.Uint32`.
func (prng *PRNG) ReadUint64AddIfShiftXOR(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state64Temp0 := prng.state64[0]
		for f := e - 8; p <= f; p += 8 {
			state64Temp0 += primeNumber64bit1
			if state64Temp0&0x02 == 0 {
				state64Temp0 ^= state64Temp0 >> 32
			}
			*(*uint64)((unsafe.Pointer)(p)) = state64Temp0
		}
		prng.state64[0] = state64Temp0
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint64AddIfShiftXOR()
	if e-p >= 4 {
		*(*uint32)((unsafe.Pointer)(p)) = uint32(rest)
		rest >>= 32
		p += 4
	}
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) = uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) = uint8(rest)
	}
	return
}

// XORReadUint64AddIfShiftXOR XORs argument "b" with a pseudo-random value.
// The result is the same (but faster) as:
//
// 	x := make([]byte, len(b))
// 	mathrand.ReadUint64AddIfShiftXOR(x)
// 	for i := range b {
// 		b[i] ^= x[i]
// 	}
func (prng *PRNG) XORReadUint64AddIfShiftXOR(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state64Temp0 := prng.state64[0]
		for f := e - 8; p <= f; p += 8 {
			state64Temp0 += primeNumber64bit1
			if state64Temp0&0x02 == 0 {
				state64Temp0 ^= state64Temp0 >> 32
			}
			*(*uint64)((unsafe.Pointer)(p)) ^= state64Temp0
		}
		prng.state64[0] = state64Temp0
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint64AddIfShiftXOR()
	if e-p >= 4 {
		*(*uint32)((unsafe.Pointer)(p)) ^= uint32(rest)
		rest >>= 32
		p += 4
	}
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) ^= uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) ^= uint8(rest)
	}
	return
}

// ReadUint64AddIfShiftXORWithReseed is an analog of math/rand.Read. This random
// numbers could easily be predicted (it's not an analog of crypto/rand.Read).
//
// "Reseed" forces to use a new seed (generated using XORShift method) on setting value to
// a pointer `& 0xff < 8`. Sometimes it allows to improve randomness of random numbers with a
// small performance impact.
// This method makes sense only if len(b) is large enough (>= 256 bytes).
// Otherwise it could affect strongly performance or it will not improve the randomness.
//
// Applied PRNG method:
// Uint64AddIfShiftXOR is a very fast (but weak) analog of `math/rand.Uint32`.
func (prng *PRNG) ReadUint64AddIfShiftXORWithReseed(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state64Temp0 := prng.state64[0]
		for f := e - 8; p <= f; p += 8 {
			state64Temp0 += primeNumber64bit1
			if state64Temp0&0x02 == 0 {
				state64Temp0 ^= state64Temp0 >> 32
			}
			*(*uint64)((unsafe.Pointer)(p)) = state64Temp0
			if p&0xff < 8 {
				continue
			}
			state64Temp0 = xorShift64(state64Temp0 ^ primeNumber64bit0)
		}
		prng.state64[0] = state64Temp0
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint64AddIfShiftXOR()
	if e-p >= 4 {
		*(*uint32)((unsafe.Pointer)(p)) = uint32(rest)
		rest >>= 32
		p += 4
	}
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) = uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) = uint8(rest)
	}
	return
}

// XORReadUint64AddIfShiftXORWithReseed XORs argument "b" with a pseudo-random value.
// The result is the same (but faster) as:
//
// 	x := make([]byte, len(b))
// 	mathrand.ReadUint64AddIfShiftXORWithReseed(x)
// 	for i := range b {
// 		b[i] ^= x[i]
// 	}
func (prng *PRNG) XORReadUint64AddIfShiftXORWithReseed(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state64Temp0 := prng.state64[0]
		for f := e - 8; p <= f; p += 8 {
			state64Temp0 += primeNumber64bit1
			if state64Temp0&0x02 == 0 {
				state64Temp0 ^= state64Temp0 >> 32
			}
			*(*uint64)((unsafe.Pointer)(p)) ^= state64Temp0
			if p&0xff < 8 {
				continue
			}
			state64Temp0 = xorShift64(state64Temp0 ^ primeNumber64bit0)
		}
		prng.state64[0] = state64Temp0
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint64AddIfShiftXOR()
	if e-p >= 4 {
		*(*uint32)((unsafe.Pointer)(p)) ^= uint32(rest)
		rest >>= 32
		p += 4
	}
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) ^= uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) ^= uint8(rest)
	}
	return
}

// ReadUint64Xorshift is an analog of math/rand.Read. This random
// numbers could easily be predicted (it's not an analog of crypto/rand.Read).
//
// Applied PRNG method:
// Uint64Xorshift is a very fast (but weak) analog of `math/rand.Uint64`.
//
// See also: https://en.wikipedia.org/wiki/Xorshift
func (prng *PRNG) ReadUint64Xorshift(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state64Temp0 := prng.state64[0]
		for f := e - 8; p <= f; p += 8 {
			state64Temp0 ^= state64Temp0 << 13
			state64Temp0 ^= state64Temp0 >> 7
			state64Temp0 ^= state64Temp0 << 17
			*(*uint64)((unsafe.Pointer)(p)) = state64Temp0
		}
		prng.state64[0] = state64Temp0
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint64Xorshift()
	if e-p >= 4 {
		*(*uint32)((unsafe.Pointer)(p)) = uint32(rest)
		rest >>= 32
		p += 4
	}
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) = uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) = uint8(rest)
	}
	return
}

// XORReadUint64Xorshift XORs argument "b" with a pseudo-random value.
// The result is the same (but faster) as:
//
// 	x := make([]byte, len(b))
// 	mathrand.ReadUint64Xorshift(x)
// 	for i := range b {
// 		b[i] ^= x[i]
// 	}
func (prng *PRNG) XORReadUint64Xorshift(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state64Temp0 := prng.state64[0]
		for f := e - 8; p <= f; p += 8 {
			state64Temp0 ^= state64Temp0 << 13
			state64Temp0 ^= state64Temp0 >> 7
			state64Temp0 ^= state64Temp0 << 17
			*(*uint64)((unsafe.Pointer)(p)) ^= state64Temp0
		}
		prng.state64[0] = state64Temp0
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint64Xorshift()
	if e-p >= 4 {
		*(*uint32)((unsafe.Pointer)(p)) ^= uint32(rest)
		rest >>= 32
		p += 4
	}
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) ^= uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) ^= uint8(rest)
	}
	return
}

// ReadUint64XorshiftWithReseed is an analog of math/rand.Read. This random
// numbers could easily be predicted (it's not an analog of crypto/rand.Read).
//
// "Reseed" forces to use a new seed (generated using XORShift method) on setting value to
// a pointer `& 0xff < 8`. Sometimes it allows to improve randomness of random numbers with a
// small performance impact.
// This method makes sense only if len(b) is large enough (>= 256 bytes).
// Otherwise it could affect strongly performance or it will not improve the randomness.
//
// Applied PRNG method:
// Uint64Xorshift is a very fast (but weak) analog of `math/rand.Uint64`.
//
// See also: https://en.wikipedia.org/wiki/Xorshift
func (prng *PRNG) ReadUint64XorshiftWithReseed(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state64Temp0 := prng.state64[0]
		for f := e - 8; p <= f; p += 8 {
			state64Temp0 ^= state64Temp0 << 13
			state64Temp0 ^= state64Temp0 >> 7
			state64Temp0 ^= state64Temp0 << 17
			*(*uint64)((unsafe.Pointer)(p)) = state64Temp0
			if p&0xff < 8 {
				continue
			}
			state64Temp0 = xorShift64(state64Temp0 ^ primeNumber64bit0)
		}
		prng.state64[0] = state64Temp0
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint64Xorshift()
	if e-p >= 4 {
		*(*uint32)((unsafe.Pointer)(p)) = uint32(rest)
		rest >>= 32
		p += 4
	}
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) = uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) = uint8(rest)
	}
	return
}

// XORReadUint64XorshiftWithReseed XORs argument "b" with a pseudo-random value.
// The result is the same (but faster) as:
//
// 	x := make([]byte, len(b))
// 	mathrand.ReadUint64XorshiftWithReseed(x)
// 	for i := range b {
// 		b[i] ^= x[i]
// 	}
func (prng *PRNG) XORReadUint64XorshiftWithReseed(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state64Temp0 := prng.state64[0]
		for f := e - 8; p <= f; p += 8 {
			state64Temp0 ^= state64Temp0 << 13
			state64Temp0 ^= state64Temp0 >> 7
			state64Temp0 ^= state64Temp0 << 17
			*(*uint64)((unsafe.Pointer)(p)) ^= state64Temp0
			if p&0xff < 8 {
				continue
			}
			state64Temp0 = xorShift64(state64Temp0 ^ primeNumber64bit0)
		}
		prng.state64[0] = state64Temp0
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint64Xorshift()
	if e-p >= 4 {
		*(*uint32)((unsafe.Pointer)(p)) ^= uint32(rest)
		rest >>= 32
		p += 4
	}
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) ^= uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) ^= uint8(rest)
	}
	return
}

// ReadUint64Xoshiro256 is an analog of math/rand.Read. This random
// numbers could easily be predicted (it's not an analog of crypto/rand.Read).
//
// Applied PRNG method:
// See also: https://en.wikipedia.org/wiki/Xorshift#xoshiro_and_xoroshiro
func (prng *PRNG) ReadUint64Xoshiro256(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		var result uint64
		state64Temp1 := prng.state64[1]
		state64Temp2 := prng.state64[2]
		state64Temp0 := prng.state64[0]
		state64Temp3 := prng.state64[3]
		for f := e - 8; p <= f; p += 8 {
			result = rotateLeft64(state64Temp1*5, 7) * 9
			t := state64Temp1 << 17
			state64Temp2 ^= state64Temp0
			state64Temp3 ^= state64Temp1
			state64Temp1 ^= state64Temp2
			state64Temp0 ^= state64Temp3
			state64Temp2 ^= t
			state64Temp3 ^= rotateLeft64(state64Temp3, 45)
			*(*uint64)((unsafe.Pointer)(p)) = result
		}
		prng.state64[1] = state64Temp1
		prng.state64[2] = state64Temp2
		prng.state64[0] = state64Temp0
		prng.state64[3] = state64Temp3
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint64Xoshiro256()
	if e-p >= 4 {
		*(*uint32)((unsafe.Pointer)(p)) = uint32(rest)
		rest >>= 32
		p += 4
	}
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) = uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) = uint8(rest)
	}
	return
}

// XORReadUint64Xoshiro256 XORs argument "b" with a pseudo-random value.
// The result is the same (but faster) as:
//
// 	x := make([]byte, len(b))
// 	mathrand.ReadUint64Xoshiro256(x)
// 	for i := range b {
// 		b[i] ^= x[i]
// 	}
func (prng *PRNG) XORReadUint64Xoshiro256(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		var result uint64
		state64Temp1 := prng.state64[1]
		state64Temp2 := prng.state64[2]
		state64Temp0 := prng.state64[0]
		state64Temp3 := prng.state64[3]
		for f := e - 8; p <= f; p += 8 {
			result = rotateLeft64(state64Temp1*5, 7) * 9
			t := state64Temp1 << 17
			state64Temp2 ^= state64Temp0
			state64Temp3 ^= state64Temp1
			state64Temp1 ^= state64Temp2
			state64Temp0 ^= state64Temp3
			state64Temp2 ^= t
			state64Temp3 ^= rotateLeft64(state64Temp3, 45)
			*(*uint64)((unsafe.Pointer)(p)) ^= result
		}
		prng.state64[1] = state64Temp1
		prng.state64[2] = state64Temp2
		prng.state64[0] = state64Temp0
		prng.state64[3] = state64Temp3
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint64Xoshiro256()
	if e-p >= 4 {
		*(*uint32)((unsafe.Pointer)(p)) ^= uint32(rest)
		rest >>= 32
		p += 4
	}
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) ^= uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) ^= uint8(rest)
	}
	return
}

// ReadUint64Xoshiro256WithReseed is an analog of math/rand.Read. This random
// numbers could easily be predicted (it's not an analog of crypto/rand.Read).
//
// "Reseed" forces to use a new seed (generated using XORShift method) on setting value to
// a pointer `& 0xff < 8`. Sometimes it allows to improve randomness of random numbers with a
// small performance impact.
// This method makes sense only if len(b) is large enough (>= 256 bytes).
// Otherwise it could affect strongly performance or it will not improve the randomness.
//
// Applied PRNG method:
// See also: https://en.wikipedia.org/wiki/Xorshift#xoshiro_and_xoroshiro
func (prng *PRNG) ReadUint64Xoshiro256WithReseed(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		var result uint64
		state64Temp1 := prng.state64[1]
		state64Temp2 := prng.state64[2]
		state64Temp0 := prng.state64[0]
		state64Temp3 := prng.state64[3]
		for f := e - 8; p <= f; p += 8 {
			result = rotateLeft64(state64Temp1*5, 7) * 9
			t := state64Temp1 << 17
			state64Temp2 ^= state64Temp0
			state64Temp3 ^= state64Temp1
			state64Temp1 ^= state64Temp2
			state64Temp0 ^= state64Temp3
			state64Temp2 ^= t
			state64Temp3 ^= rotateLeft64(state64Temp3, 45)
			*(*uint64)((unsafe.Pointer)(p)) = result
			if p&0xff < 8 {
				continue
			}
			state64Temp0 = xorShift64(state64Temp0 ^ primeNumber64bit0)
		}
		prng.state64[1] = state64Temp1
		prng.state64[2] = state64Temp2
		prng.state64[0] = state64Temp0
		prng.state64[3] = state64Temp3
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint64Xoshiro256()
	if e-p >= 4 {
		*(*uint32)((unsafe.Pointer)(p)) = uint32(rest)
		rest >>= 32
		p += 4
	}
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) = uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) = uint8(rest)
	}
	return
}

// XORReadUint64Xoshiro256WithReseed XORs argument "b" with a pseudo-random value.
// The result is the same (but faster) as:
//
// 	x := make([]byte, len(b))
// 	mathrand.ReadUint64Xoshiro256WithReseed(x)
// 	for i := range b {
// 		b[i] ^= x[i]
// 	}
func (prng *PRNG) XORReadUint64Xoshiro256WithReseed(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		var result uint64
		state64Temp1 := prng.state64[1]
		state64Temp2 := prng.state64[2]
		state64Temp0 := prng.state64[0]
		state64Temp3 := prng.state64[3]
		for f := e - 8; p <= f; p += 8 {
			result = rotateLeft64(state64Temp1*5, 7) * 9
			t := state64Temp1 << 17
			state64Temp2 ^= state64Temp0
			state64Temp3 ^= state64Temp1
			state64Temp1 ^= state64Temp2
			state64Temp0 ^= state64Temp3
			state64Temp2 ^= t
			state64Temp3 ^= rotateLeft64(state64Temp3, 45)
			*(*uint64)((unsafe.Pointer)(p)) ^= result
			if p&0xff < 8 {
				continue
			}
			state64Temp0 = xorShift64(state64Temp0 ^ primeNumber64bit0)
		}
		prng.state64[1] = state64Temp1
		prng.state64[2] = state64Temp2
		prng.state64[0] = state64Temp0
		prng.state64[3] = state64Temp3
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint64Xoshiro256()
	if e-p >= 4 {
		*(*uint32)((unsafe.Pointer)(p)) ^= uint32(rest)
		rest >>= 32
		p += 4
	}
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) ^= uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) ^= uint8(rest)
	}
	return
}

// ReadUint64MSWS is an analog of math/rand.Read. This random
// numbers could easily be predicted (it's not an analog of crypto/rand.Read).
//
// Applied PRNG method:
// See also: https://en.wikipedia.org/wiki/Middle-square_method
func (prng *PRNG) ReadUint64MSWS(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state64Temp0 := prng.state64[0]
		state64Temp1 := prng.state64[1]
		for f := e - 8; p <= f; p += 8 {
			state64Temp0 *= state64Temp0
			state64Temp1 += mswsSeed
			state64Temp0 += state64Temp1
			state64Temp0 = rotateLeft64(state64Temp0, 32)
			*(*uint64)((unsafe.Pointer)(p)) = state64Temp0
		}
		prng.state64[0] = state64Temp0
		prng.state64[1] = state64Temp1
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint64MSWS()
	if e-p >= 4 {
		*(*uint32)((unsafe.Pointer)(p)) = uint32(rest)
		rest >>= 32
		p += 4
	}
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) = uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) = uint8(rest)
	}
	return
}

// XORReadUint64MSWS XORs argument "b" with a pseudo-random value.
// The result is the same (but faster) as:
//
// 	x := make([]byte, len(b))
// 	mathrand.ReadUint64MSWS(x)
// 	for i := range b {
// 		b[i] ^= x[i]
// 	}
func (prng *PRNG) XORReadUint64MSWS(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state64Temp0 := prng.state64[0]
		state64Temp1 := prng.state64[1]
		for f := e - 8; p <= f; p += 8 {
			state64Temp0 *= state64Temp0
			state64Temp1 += mswsSeed
			state64Temp0 += state64Temp1
			state64Temp0 = rotateLeft64(state64Temp0, 32)
			*(*uint64)((unsafe.Pointer)(p)) ^= state64Temp0
		}
		prng.state64[0] = state64Temp0
		prng.state64[1] = state64Temp1
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint64MSWS()
	if e-p >= 4 {
		*(*uint32)((unsafe.Pointer)(p)) ^= uint32(rest)
		rest >>= 32
		p += 4
	}
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) ^= uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) ^= uint8(rest)
	}
	return
}

// ReadUint64MSWSWithReseed is an analog of math/rand.Read. This random
// numbers could easily be predicted (it's not an analog of crypto/rand.Read).
//
// "Reseed" forces to use a new seed (generated using XORShift method) on setting value to
// a pointer `& 0xff < 8`. Sometimes it allows to improve randomness of random numbers with a
// small performance impact.
// This method makes sense only if len(b) is large enough (>= 256 bytes).
// Otherwise it could affect strongly performance or it will not improve the randomness.
//
// Applied PRNG method:
// See also: https://en.wikipedia.org/wiki/Middle-square_method
func (prng *PRNG) ReadUint64MSWSWithReseed(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state64Temp0 := prng.state64[0]
		state64Temp1 := prng.state64[1]
		for f := e - 8; p <= f; p += 8 {
			state64Temp0 *= state64Temp0
			state64Temp1 += mswsSeed
			state64Temp0 += state64Temp1
			state64Temp0 = rotateLeft64(state64Temp0, 32)
			*(*uint64)((unsafe.Pointer)(p)) = state64Temp0
			if p&0xff < 8 {
				continue
			}
			state64Temp0 = xorShift64(state64Temp0 ^ primeNumber64bit0)
		}
		prng.state64[0] = state64Temp0
		prng.state64[1] = state64Temp1
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint64MSWS()
	if e-p >= 4 {
		*(*uint32)((unsafe.Pointer)(p)) = uint32(rest)
		rest >>= 32
		p += 4
	}
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) = uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) = uint8(rest)
	}
	return
}

// XORReadUint64MSWSWithReseed XORs argument "b" with a pseudo-random value.
// The result is the same (but faster) as:
//
// 	x := make([]byte, len(b))
// 	mathrand.ReadUint64MSWSWithReseed(x)
// 	for i := range b {
// 		b[i] ^= x[i]
// 	}
func (prng *PRNG) XORReadUint64MSWSWithReseed(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state64Temp0 := prng.state64[0]
		state64Temp1 := prng.state64[1]
		for f := e - 8; p <= f; p += 8 {
			state64Temp0 *= state64Temp0
			state64Temp1 += mswsSeed
			state64Temp0 += state64Temp1
			state64Temp0 = rotateLeft64(state64Temp0, 32)
			*(*uint64)((unsafe.Pointer)(p)) ^= state64Temp0
			if p&0xff < 8 {
				continue
			}
			state64Temp0 = xorShift64(state64Temp0 ^ primeNumber64bit0)
		}
		prng.state64[0] = state64Temp0
		prng.state64[1] = state64Temp1
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint64MSWS()
	if e-p >= 4 {
		*(*uint32)((unsafe.Pointer)(p)) ^= uint32(rest)
		rest >>= 32
		p += 4
	}
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) ^= uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) ^= uint8(rest)
	}
	return
}

// ReadUint32AddRotateMultiply is an analog of math/rand.Read. This random
// numbers could easily be predicted (it's not an analog of crypto/rand.Read).
//
// Applied PRNG method:
// Uint32AddRotateMultiply is a fast analog of `math/rand.Uint32`.
//
// The reliability on statistical tests of this method is unknown. This is
// improved LCG method, so see also Uint32MultiplyAdd.
func (prng *PRNG) ReadUint32AddRotateMultiply(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state32Temp0 := prng.state32[0]
		for f := e - 4; p <= f; p += 4 {
			state32Temp0 += primeNumber32bit1
			state32Temp0 = rotateLeft32(state32Temp0, 32)
			state32Temp0 *= primeNumber32bit0
			*(*uint32)((unsafe.Pointer)(p)) = state32Temp0
		}
		prng.state32[0] = state32Temp0
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint32AddRotateMultiply()
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) = uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) = uint8(rest)
	}
	return
}

// XORReadUint32AddRotateMultiply XORs argument "b" with a pseudo-random value.
// The result is the same (but faster) as:
//
// 	x := make([]byte, len(b))
// 	mathrand.ReadUint32AddRotateMultiply(x)
// 	for i := range b {
// 		b[i] ^= x[i]
// 	}
func (prng *PRNG) XORReadUint32AddRotateMultiply(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state32Temp0 := prng.state32[0]
		for f := e - 4; p <= f; p += 4 {
			state32Temp0 += primeNumber32bit1
			state32Temp0 = rotateLeft32(state32Temp0, 32)
			state32Temp0 *= primeNumber32bit0
			*(*uint32)((unsafe.Pointer)(p)) ^= state32Temp0
		}
		prng.state32[0] = state32Temp0
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint32AddRotateMultiply()
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) ^= uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) ^= uint8(rest)
	}
	return
}

// ReadUint32AddRotateMultiplyWithReseed is an analog of math/rand.Read. This random
// numbers could easily be predicted (it's not an analog of crypto/rand.Read).
//
// "Reseed" forces to use a new seed (generated using XORShift method) on setting value to
// a pointer `& 0xff < 4`. Sometimes it allows to improve randomness of random numbers with a
// small performance impact.
// This method makes sense only if len(b) is large enough (>= 256 bytes).
// Otherwise it could affect strongly performance or it will not improve the randomness.
//
// Applied PRNG method:
// Uint32AddRotateMultiply is a fast analog of `math/rand.Uint32`.
//
// The reliability on statistical tests of this method is unknown. This is
// improved LCG method, so see also Uint32MultiplyAdd.
func (prng *PRNG) ReadUint32AddRotateMultiplyWithReseed(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state32Temp0 := prng.state32[0]
		for f := e - 4; p <= f; p += 4 {
			state32Temp0 += primeNumber32bit1
			state32Temp0 = rotateLeft32(state32Temp0, 32)
			state32Temp0 *= primeNumber32bit0
			*(*uint32)((unsafe.Pointer)(p)) = state32Temp0
			if p&0xff < 4 {
				continue
			}
			state32Temp0 = (uint32)(xorShift32(state32Temp0 ^ primeNumber32bit0))
		}
		prng.state32[0] = state32Temp0
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint32AddRotateMultiply()
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) = uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) = uint8(rest)
	}
	return
}

// XORReadUint32AddRotateMultiplyWithReseed XORs argument "b" with a pseudo-random value.
// The result is the same (but faster) as:
//
// 	x := make([]byte, len(b))
// 	mathrand.ReadUint32AddRotateMultiplyWithReseed(x)
// 	for i := range b {
// 		b[i] ^= x[i]
// 	}
func (prng *PRNG) XORReadUint32AddRotateMultiplyWithReseed(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state32Temp0 := prng.state32[0]
		for f := e - 4; p <= f; p += 4 {
			state32Temp0 += primeNumber32bit1
			state32Temp0 = rotateLeft32(state32Temp0, 32)
			state32Temp0 *= primeNumber32bit0
			*(*uint32)((unsafe.Pointer)(p)) ^= state32Temp0
			if p&0xff < 4 {
				continue
			}
			state32Temp0 = (uint32)(xorShift32(state32Temp0 ^ primeNumber32bit0))
		}
		prng.state32[0] = state32Temp0
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint32AddRotateMultiply()
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) ^= uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) ^= uint8(rest)
	}
	return
}

// ReadUint32MultiplyAdd is an analog of math/rand.Read. This random
// numbers could easily be predicted (it's not an analog of crypto/rand.Read).
//
// Applied PRNG method:
// Uint32MultiplyAdd is a fast (but week) analog of `math/rand.Uint32`.
//
// See also: https://en.wikipedia.org/wiki/Linear_congruential_generator
func (prng *PRNG) ReadUint32MultiplyAdd(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state32Temp0 := prng.state32[0]
		for f := e - 4; p <= f; p += 4 {
			state32Temp0 *= primeNumber32bit0
			state32Temp0 += primeNumber32bit1
			*(*uint32)((unsafe.Pointer)(p)) = state32Temp0
		}
		prng.state32[0] = state32Temp0
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint32MultiplyAdd()
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) = uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) = uint8(rest)
	}
	return
}

// XORReadUint32MultiplyAdd XORs argument "b" with a pseudo-random value.
// The result is the same (but faster) as:
//
// 	x := make([]byte, len(b))
// 	mathrand.ReadUint32MultiplyAdd(x)
// 	for i := range b {
// 		b[i] ^= x[i]
// 	}
func (prng *PRNG) XORReadUint32MultiplyAdd(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state32Temp0 := prng.state32[0]
		for f := e - 4; p <= f; p += 4 {
			state32Temp0 *= primeNumber32bit0
			state32Temp0 += primeNumber32bit1
			*(*uint32)((unsafe.Pointer)(p)) ^= state32Temp0
		}
		prng.state32[0] = state32Temp0
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint32MultiplyAdd()
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) ^= uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) ^= uint8(rest)
	}
	return
}

// ReadUint32MultiplyAddWithReseed is an analog of math/rand.Read. This random
// numbers could easily be predicted (it's not an analog of crypto/rand.Read).
//
// "Reseed" forces to use a new seed (generated using XORShift method) on setting value to
// a pointer `& 0xff < 4`. Sometimes it allows to improve randomness of random numbers with a
// small performance impact.
// This method makes sense only if len(b) is large enough (>= 256 bytes).
// Otherwise it could affect strongly performance or it will not improve the randomness.
//
// Applied PRNG method:
// Uint32MultiplyAdd is a fast (but week) analog of `math/rand.Uint32`.
//
// See also: https://en.wikipedia.org/wiki/Linear_congruential_generator
func (prng *PRNG) ReadUint32MultiplyAddWithReseed(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state32Temp0 := prng.state32[0]
		for f := e - 4; p <= f; p += 4 {
			state32Temp0 *= primeNumber32bit0
			state32Temp0 += primeNumber32bit1
			*(*uint32)((unsafe.Pointer)(p)) = state32Temp0
			if p&0xff < 4 {
				continue
			}
			state32Temp0 = (uint32)(xorShift32(state32Temp0 ^ primeNumber32bit0))
		}
		prng.state32[0] = state32Temp0
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint32MultiplyAdd()
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) = uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) = uint8(rest)
	}
	return
}

// XORReadUint32MultiplyAddWithReseed XORs argument "b" with a pseudo-random value.
// The result is the same (but faster) as:
//
// 	x := make([]byte, len(b))
// 	mathrand.ReadUint32MultiplyAddWithReseed(x)
// 	for i := range b {
// 		b[i] ^= x[i]
// 	}
func (prng *PRNG) XORReadUint32MultiplyAddWithReseed(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state32Temp0 := prng.state32[0]
		for f := e - 4; p <= f; p += 4 {
			state32Temp0 *= primeNumber32bit0
			state32Temp0 += primeNumber32bit1
			*(*uint32)((unsafe.Pointer)(p)) ^= state32Temp0
			if p&0xff < 4 {
				continue
			}
			state32Temp0 = (uint32)(xorShift32(state32Temp0 ^ primeNumber32bit0))
		}
		prng.state32[0] = state32Temp0
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint32MultiplyAdd()
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) ^= uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) ^= uint8(rest)
	}
	return
}

// ReadUint32AddRotate is an analog of math/rand.Read. This random
// numbers could easily be predicted (it's not an analog of crypto/rand.Read).
//
// Applied PRNG method:
// Uint32AddRotate is a very fast (but weak) analog of `math/rand.Uint32`.
func (prng *PRNG) ReadUint32AddRotate(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state32Temp0 := prng.state32[0]
		for f := e - 4; p <= f; p += 4 {
			state32Temp0 += primeNumber32bit0
			state32Temp0 = rotateLeft32(state32Temp0, 32)
			*(*uint32)((unsafe.Pointer)(p)) = state32Temp0
		}
		prng.state32[0] = state32Temp0
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint32AddRotate()
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) = uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) = uint8(rest)
	}
	return
}

// XORReadUint32AddRotate XORs argument "b" with a pseudo-random value.
// The result is the same (but faster) as:
//
// 	x := make([]byte, len(b))
// 	mathrand.ReadUint32AddRotate(x)
// 	for i := range b {
// 		b[i] ^= x[i]
// 	}
func (prng *PRNG) XORReadUint32AddRotate(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state32Temp0 := prng.state32[0]
		for f := e - 4; p <= f; p += 4 {
			state32Temp0 += primeNumber32bit0
			state32Temp0 = rotateLeft32(state32Temp0, 32)
			*(*uint32)((unsafe.Pointer)(p)) ^= state32Temp0
		}
		prng.state32[0] = state32Temp0
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint32AddRotate()
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) ^= uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) ^= uint8(rest)
	}
	return
}

// ReadUint32AddRotateWithReseed is an analog of math/rand.Read. This random
// numbers could easily be predicted (it's not an analog of crypto/rand.Read).
//
// "Reseed" forces to use a new seed (generated using XORShift method) on setting value to
// a pointer `& 0xff < 4`. Sometimes it allows to improve randomness of random numbers with a
// small performance impact.
// This method makes sense only if len(b) is large enough (>= 256 bytes).
// Otherwise it could affect strongly performance or it will not improve the randomness.
//
// Applied PRNG method:
// Uint32AddRotate is a very fast (but weak) analog of `math/rand.Uint32`.
func (prng *PRNG) ReadUint32AddRotateWithReseed(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state32Temp0 := prng.state32[0]
		for f := e - 4; p <= f; p += 4 {
			state32Temp0 += primeNumber32bit0
			state32Temp0 = rotateLeft32(state32Temp0, 32)
			*(*uint32)((unsafe.Pointer)(p)) = state32Temp0
			if p&0xff < 4 {
				continue
			}
			state32Temp0 = (uint32)(xorShift32(state32Temp0 ^ primeNumber32bit0))
		}
		prng.state32[0] = state32Temp0
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint32AddRotate()
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) = uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) = uint8(rest)
	}
	return
}

// XORReadUint32AddRotateWithReseed XORs argument "b" with a pseudo-random value.
// The result is the same (but faster) as:
//
// 	x := make([]byte, len(b))
// 	mathrand.ReadUint32AddRotateWithReseed(x)
// 	for i := range b {
// 		b[i] ^= x[i]
// 	}
func (prng *PRNG) XORReadUint32AddRotateWithReseed(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state32Temp0 := prng.state32[0]
		for f := e - 4; p <= f; p += 4 {
			state32Temp0 += primeNumber32bit0
			state32Temp0 = rotateLeft32(state32Temp0, 32)
			*(*uint32)((unsafe.Pointer)(p)) ^= state32Temp0
			if p&0xff < 4 {
				continue
			}
			state32Temp0 = (uint32)(xorShift32(state32Temp0 ^ primeNumber32bit0))
		}
		prng.state32[0] = state32Temp0
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint32AddRotate()
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) ^= uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) ^= uint8(rest)
	}
	return
}

// ReadUint32AddIfShiftXOR is an analog of math/rand.Read. This random
// numbers could easily be predicted (it's not an analog of crypto/rand.Read).
//
// Applied PRNG method:
// Uint32AddIfShiftXOR is a very fast (but weak) analog of `math/rand.Uint32`.
func (prng *PRNG) ReadUint32AddIfShiftXOR(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state32Temp0 := prng.state32[0]
		for f := e - 4; p <= f; p += 4 {
			state32Temp0 += primeNumber32bit1
			if state32Temp0&0x02 == 0 {
				state32Temp0 ^= state32Temp0 >> 16
			}
			*(*uint32)((unsafe.Pointer)(p)) = state32Temp0
		}
		prng.state32[0] = state32Temp0
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint32AddIfShiftXOR()
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) = uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) = uint8(rest)
	}
	return
}

// XORReadUint32AddIfShiftXOR XORs argument "b" with a pseudo-random value.
// The result is the same (but faster) as:
//
// 	x := make([]byte, len(b))
// 	mathrand.ReadUint32AddIfShiftXOR(x)
// 	for i := range b {
// 		b[i] ^= x[i]
// 	}
func (prng *PRNG) XORReadUint32AddIfShiftXOR(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state32Temp0 := prng.state32[0]
		for f := e - 4; p <= f; p += 4 {
			state32Temp0 += primeNumber32bit1
			if state32Temp0&0x02 == 0 {
				state32Temp0 ^= state32Temp0 >> 16
			}
			*(*uint32)((unsafe.Pointer)(p)) ^= state32Temp0
		}
		prng.state32[0] = state32Temp0
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint32AddIfShiftXOR()
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) ^= uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) ^= uint8(rest)
	}
	return
}

// ReadUint32AddIfShiftXORWithReseed is an analog of math/rand.Read. This random
// numbers could easily be predicted (it's not an analog of crypto/rand.Read).
//
// "Reseed" forces to use a new seed (generated using XORShift method) on setting value to
// a pointer `& 0xff < 4`. Sometimes it allows to improve randomness of random numbers with a
// small performance impact.
// This method makes sense only if len(b) is large enough (>= 256 bytes).
// Otherwise it could affect strongly performance or it will not improve the randomness.
//
// Applied PRNG method:
// Uint32AddIfShiftXOR is a very fast (but weak) analog of `math/rand.Uint32`.
func (prng *PRNG) ReadUint32AddIfShiftXORWithReseed(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state32Temp0 := prng.state32[0]
		for f := e - 4; p <= f; p += 4 {
			state32Temp0 += primeNumber32bit1
			if state32Temp0&0x02 == 0 {
				state32Temp0 ^= state32Temp0 >> 16
			}
			*(*uint32)((unsafe.Pointer)(p)) = state32Temp0
			if p&0xff < 4 {
				continue
			}
			state32Temp0 = (uint32)(xorShift32(state32Temp0 ^ primeNumber32bit0))
		}
		prng.state32[0] = state32Temp0
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint32AddIfShiftXOR()
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) = uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) = uint8(rest)
	}
	return
}

// XORReadUint32AddIfShiftXORWithReseed XORs argument "b" with a pseudo-random value.
// The result is the same (but faster) as:
//
// 	x := make([]byte, len(b))
// 	mathrand.ReadUint32AddIfShiftXORWithReseed(x)
// 	for i := range b {
// 		b[i] ^= x[i]
// 	}
func (prng *PRNG) XORReadUint32AddIfShiftXORWithReseed(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state32Temp0 := prng.state32[0]
		for f := e - 4; p <= f; p += 4 {
			state32Temp0 += primeNumber32bit1
			if state32Temp0&0x02 == 0 {
				state32Temp0 ^= state32Temp0 >> 16
			}
			*(*uint32)((unsafe.Pointer)(p)) ^= state32Temp0
			if p&0xff < 4 {
				continue
			}
			state32Temp0 = (uint32)(xorShift32(state32Temp0 ^ primeNumber32bit0))
		}
		prng.state32[0] = state32Temp0
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint32AddIfShiftXOR()
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) ^= uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) ^= uint8(rest)
	}
	return
}

// ReadUint32Xorshift is an analog of math/rand.Read. This random
// numbers could easily be predicted (it's not an analog of crypto/rand.Read).
//
// Applied PRNG method:
// Uint32Xorshift is a very fast (but weak) analog of `math/rand.Uint32`.
//
// See also: https://en.wikipedia.org/wiki/Xorshift
func (prng *PRNG) ReadUint32Xorshift(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state32Temp0 := prng.state32[0]
		for f := e - 4; p <= f; p += 4 {
			state32Temp0 ^= state32Temp0 << 13
			state32Temp0 ^= state32Temp0 >> 17
			state32Temp0 ^= state32Temp0 << 5
			*(*uint32)((unsafe.Pointer)(p)) = state32Temp0
		}
		prng.state32[0] = state32Temp0
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint32Xorshift()
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) = uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) = uint8(rest)
	}
	return
}

// XORReadUint32Xorshift XORs argument "b" with a pseudo-random value.
// The result is the same (but faster) as:
//
// 	x := make([]byte, len(b))
// 	mathrand.ReadUint32Xorshift(x)
// 	for i := range b {
// 		b[i] ^= x[i]
// 	}
func (prng *PRNG) XORReadUint32Xorshift(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state32Temp0 := prng.state32[0]
		for f := e - 4; p <= f; p += 4 {
			state32Temp0 ^= state32Temp0 << 13
			state32Temp0 ^= state32Temp0 >> 17
			state32Temp0 ^= state32Temp0 << 5
			*(*uint32)((unsafe.Pointer)(p)) ^= state32Temp0
		}
		prng.state32[0] = state32Temp0
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint32Xorshift()
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) ^= uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) ^= uint8(rest)
	}
	return
}

// ReadUint32XorshiftWithReseed is an analog of math/rand.Read. This random
// numbers could easily be predicted (it's not an analog of crypto/rand.Read).
//
// "Reseed" forces to use a new seed (generated using XORShift method) on setting value to
// a pointer `& 0xff < 4`. Sometimes it allows to improve randomness of random numbers with a
// small performance impact.
// This method makes sense only if len(b) is large enough (>= 256 bytes).
// Otherwise it could affect strongly performance or it will not improve the randomness.
//
// Applied PRNG method:
// Uint32Xorshift is a very fast (but weak) analog of `math/rand.Uint32`.
//
// See also: https://en.wikipedia.org/wiki/Xorshift
func (prng *PRNG) ReadUint32XorshiftWithReseed(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state32Temp0 := prng.state32[0]
		for f := e - 4; p <= f; p += 4 {
			state32Temp0 ^= state32Temp0 << 13
			state32Temp0 ^= state32Temp0 >> 17
			state32Temp0 ^= state32Temp0 << 5
			*(*uint32)((unsafe.Pointer)(p)) = state32Temp0
			if p&0xff < 4 {
				continue
			}
			state32Temp0 = (uint32)(xorShift32(state32Temp0 ^ primeNumber32bit0))
		}
		prng.state32[0] = state32Temp0
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint32Xorshift()
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) = uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) = uint8(rest)
	}
	return
}

// XORReadUint32XorshiftWithReseed XORs argument "b" with a pseudo-random value.
// The result is the same (but faster) as:
//
// 	x := make([]byte, len(b))
// 	mathrand.ReadUint32XorshiftWithReseed(x)
// 	for i := range b {
// 		b[i] ^= x[i]
// 	}
func (prng *PRNG) XORReadUint32XorshiftWithReseed(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		state32Temp0 := prng.state32[0]
		for f := e - 4; p <= f; p += 4 {
			state32Temp0 ^= state32Temp0 << 13
			state32Temp0 ^= state32Temp0 >> 17
			state32Temp0 ^= state32Temp0 << 5
			*(*uint32)((unsafe.Pointer)(p)) ^= state32Temp0
			if p&0xff < 4 {
				continue
			}
			state32Temp0 = (uint32)(xorShift32(state32Temp0 ^ primeNumber32bit0))
		}
		prng.state32[0] = state32Temp0
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint32Xorshift()
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) ^= uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) ^= uint8(rest)
	}
	return
}

// ReadUint32PCG is an analog of math/rand.Read. This random
// numbers could easily be predicted (it's not an analog of crypto/rand.Read).
//
// Applied PRNG method:
// See also: https://en.wikipedia.org/wiki/Permuted_congruential_generator
func (prng *PRNG) ReadUint32PCG(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		pcgStateTemp := prng.pcgState
		for f := e - 4; p <= f; p += 4 {
			x := pcgStateTemp
			count := int(x >> 59)
			pcgStateTemp = x*pcgMultiplier + pcgIncrement
			x ^= x >> 18
			*(*uint32)((unsafe.Pointer)(p)) = rotateRight32(uint32(x>>27), count)
		}
		prng.pcgState = pcgStateTemp
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint32PCG()
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) = uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) = uint8(rest)
	}
	return
}

// XORReadUint32PCG XORs argument "b" with a pseudo-random value.
// The result is the same (but faster) as:
//
// 	x := make([]byte, len(b))
// 	mathrand.ReadUint32PCG(x)
// 	for i := range b {
// 		b[i] ^= x[i]
// 	}
func (prng *PRNG) XORReadUint32PCG(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		pcgStateTemp := prng.pcgState
		for f := e - 4; p <= f; p += 4 {
			x := pcgStateTemp
			count := int(x >> 59)
			pcgStateTemp = x*pcgMultiplier + pcgIncrement
			x ^= x >> 18
			*(*uint32)((unsafe.Pointer)(p)) ^= rotateRight32(uint32(x>>27), count)
		}
		prng.pcgState = pcgStateTemp
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint32PCG()
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) ^= uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) ^= uint8(rest)
	}
	return
}

// ReadUint32PCGWithReseed is an analog of math/rand.Read. This random
// numbers could easily be predicted (it's not an analog of crypto/rand.Read).
//
// "Reseed" forces to use a new seed (generated using XORShift method) on setting value to
// a pointer `& 0xff < 4`. Sometimes it allows to improve randomness of random numbers with a
// small performance impact.
// This method makes sense only if len(b) is large enough (>= 256 bytes).
// Otherwise it could affect strongly performance or it will not improve the randomness.
//
// Applied PRNG method:
// See also: https://en.wikipedia.org/wiki/Permuted_congruential_generator
func (prng *PRNG) ReadUint32PCGWithReseed(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		pcgStateTemp := prng.pcgState
		for f := e - 4; p <= f; p += 4 {
			x := pcgStateTemp
			count := int(x >> 59)
			pcgStateTemp = x*pcgMultiplier + pcgIncrement
			x ^= x >> 18
			*(*uint32)((unsafe.Pointer)(p)) = rotateRight32(uint32(x>>27), count)
			if p&0xff < 4 {
				continue
			}
			pcgStateTemp = xorShift64(pcgStateTemp^primeNumber64bit0)<<1 + 1
		}
		prng.pcgState = pcgStateTemp
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint32PCG()
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) = uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) = uint8(rest)
	}
	return
}

// XORReadUint32PCGWithReseed XORs argument "b" with a pseudo-random value.
// The result is the same (but faster) as:
//
// 	x := make([]byte, len(b))
// 	mathrand.ReadUint32PCGWithReseed(x)
// 	for i := range b {
// 		b[i] ^= x[i]
// 	}
func (prng *PRNG) XORReadUint32PCGWithReseed(b []byte) (l int, err error) {
	l = len(b)
	s := (uintptr)((unsafe.Pointer)(&b[0]))
	p := s
	e := s + uintptr(l)
	{
		pcgStateTemp := prng.pcgState
		for f := e - 4; p <= f; p += 4 {
			x := pcgStateTemp
			count := int(x >> 59)
			pcgStateTemp = x*pcgMultiplier + pcgIncrement
			x ^= x >> 18
			*(*uint32)((unsafe.Pointer)(p)) ^= rotateRight32(uint32(x>>27), count)
			if p&0xff < 4 {
				continue
			}
			pcgStateTemp = xorShift64(pcgStateTemp^primeNumber64bit0)<<1 + 1
		}
		prng.pcgState = pcgStateTemp
	}

	if e-p == 0 {
		return
	}
	rest := prng.Uint32PCG()
	if e-p >= 2 {
		*(*uint16)((unsafe.Pointer)(p)) ^= uint16(rest)
		rest >>= 16
		p += 2
	}
	if e-p >= 1 {
		*(*uint8)((unsafe.Pointer)(p)) ^= uint8(rest)
	}
	return
}
